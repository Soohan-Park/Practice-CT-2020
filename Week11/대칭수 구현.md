# 대칭수 구현 [Python3]

### Prob.

`(1,2), (2,3), (3,4), (5,6), (3, 2)` 가 있을 때, (2,3)을 대칭수라고 한다. `[ (2,3) & (3,2) ]` 이러한 대칭수를 찾아내는 알고리즘을 작성하시오.  

<br/>

### Sol.

* 왜 당시에는 이 문제를 풀지 못했는지 이해가 가지 않을 정도로 구현하기는 쉬웠던 문제인 것 같음.  
* 다시 한 번 풀어보면서, 다음부터는 너무 긴장하지 말고 좀 더 편안하게 집중을 해야겠다는 교훈을 얻음.  
* `O(n*logn)` 의 시간복잡도로 구현.

<br/>
<br/>

이전 `Combination 구현`하는 문제처럼, 모 기업 면접에서 위와 같은 문제가 나왔었다. 당시 정말... 왜인지는 모르겠지만 ~~*(Combination 문제를 망쳐서 그런가..)*~~ 이 쉬운 문제를 긴장해서 그런지, 아무것도 못해보고 나왔다.  

이후, 다시는 이런 실수를 하지 말자는 의미에서 다시 한 번 문제를 복기해보고, 이를 남겨본다.  

<br/>

문제가 간단했기에, 아래에 접근 방법만 작성해보겠다. 

<br/>

```txt
1. 좀 더 좋은 효율성을 위해 위 수들을 정렬. (오름차순, 0, 1 인덱스 순으로)  

2. 이중 반복문을 통해 순차적으로 탐색한다.  
   이 때, 반복 j는 반복 i 인덱스보다 앞의 수를 탐색할 필요는 없다. (이미 탐색되었기 때문)  

3. 대칭수 조건에 만족하는 경우 pool에 저장하고, 추후 이를 출력.  
```

<br/>

구현된 코드는 아래와 같다. (효율성에 대해선 좀 더 고민을 해봐야겠다.)

<br/>

```python
def f(target):
	pool = []

	for i in range(0, len(target)-1): # 맨 마지막 수 탐색 제외
		num1 = target[i]
		for j in range(i+1, len(target)):
			num2 = target[j]
			if num1[0] == num2[1] and num1[1] == num2[0]: # This is DAECHING-SU!
				pool.append([ num1, num2 ])

	for p in pool:
		print(p)


if __name__ == '__main__':
	target = [(1,2), (2,3), (3,4), (5,6), (3,2)]

	target.sort(key=lambda x : (x[0], x[1])) # Sorted. Because more efficiency.

	f(target)
```
